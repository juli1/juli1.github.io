<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julien Delange</title>
    <description>Harder, Better, Faster, Stronger</description>
    <link>http://julien.gunnm.org/</link>
    <atom:link href="http://julien.gunnm.org/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 12 Dec 2020 03:34:18 +0000</pubDate>
    <lastBuildDate>Sat, 12 Dec 2020 03:34:18 +0000</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>On immutability</title>
        <description>&lt;p&gt;&lt;em&gt;Note: this page is part of the &lt;a href=&quot;/software engineering/essay/2020/03/06/software-engineering-series&quot;&gt;‚ÄúEssays on Software Engineering‚Äù&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I discovered Scala and functional programming when I joined Twitter. Scala
introduced me to this new world
of pure functions and immutability. I loved it so much that I started teaching
the language for all new employees (if you ever attended my class, I
apologize for all the bad puns and jokes I made).&lt;/p&gt;

&lt;p&gt;Over the years, I really embraced functional programming as a discipline.
No matter what language I used, I try to always stick to some keys principles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;pure functions&lt;/strong&gt;: the output of a function depends only on its inputs.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;immutability&lt;/strong&gt;: keep all data immutable, any modification results in a copy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to use a functional
programming language to use these principles, you can apply them
to almost any language. I use them while coding in Java and Python.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/John_Carmack&quot;&gt;John Carmack&lt;/a&gt;
also tried to apply these principles when building
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Id_Tech_4&quot;&gt;Doom 3 3D engine (idTech 4)&lt;/a&gt;, built
using C++.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/1PhArSujR_A?start=124&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;I will skips the reason to use functional programming and focus on immutability.&lt;/p&gt;

&lt;h1 id=&quot;idempotence-and-determinism&quot;&gt;Idempotence and determinism&lt;/h1&gt;

&lt;p&gt;You want your function to be easy to understand and test. Ideally, you want
the result of a function to be idem-potent: no matter how many times you
invoke the function, you get the same result if you provide the same inputs.&lt;/p&gt;

&lt;p&gt;That rule is being verified if you use immutable data, let‚Äôs illustrate this
principle with an example.&lt;/p&gt;

&lt;p&gt;Let‚Äôs consider a class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Person&lt;/code&gt; in an hybrid language:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case class Person(name: String, age: Int)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, let‚Äôs define two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;older&lt;/code&gt; functions. One that mutates the value
passed as parameters (let‚Äôs assume parameters are mutable).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person older(person: Person, age: Int) {
  person.age = person.age + age;
  return person;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And another &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;older&lt;/code&gt; function where we use immutable data (and we copy the argument).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person older(person: Person, age: Int) {
  return person.copy(age = person.age + age);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, consider the following block of code&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person p = Person(&quot;foo&quot;, 42);

Person p2 = older(p, 10);
Person p3 = older(p, 10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ideally, what you really want is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2 == p3&lt;/code&gt; since they both have the same
inputs. Unfortunately, this will not work with the first function
since we mutate the value ahead of time. If you use the first
function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p3.age == 62&lt;/code&gt; and if you use the first function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p3.age == 52&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The problem is that such mutation will spread in your codebase like the
plague and will make really difficult to follow the codepath. Let 10
developers follow such practices and you will end up with spaghetti code
that becomes a nightmare to understand.&lt;/p&gt;

&lt;p&gt;Immutability comes hand in hand with pure functions. If you want to embrace
immutability, embrace pure functions.&lt;/p&gt;

&lt;h1 id=&quot;parallelism&quot;&gt;Parallelism&lt;/h1&gt;

&lt;p&gt;One of the hardest problem on computer science is to write correct
parallel programs. With computers having multiple cores all programs are
multi-threaded and data is being shared between cores/thread, which
requires to use locking mechanism (e.g. mutex, semaphore, etc.).&lt;/p&gt;

&lt;p&gt;The reason we use mutex is precisely because a data is being mutated and
we want to guarantee only one thread modifies a data at a time. If you
use immutable data structure, these problems are non-existent for you
since you &lt;em&gt;never&lt;/em&gt; modify data structure (you always copy and create
new data).&lt;/p&gt;

&lt;p&gt;In other words, using immutable data let‚Äôs you write scalable programs
from the start.&lt;/p&gt;

&lt;h1 id=&quot;the-cost-of-immutability&quot;&gt;The cost of immutability&lt;/h1&gt;

&lt;p&gt;The recurrent against immutable data is the additional runtime cost. The argument is that
using immutable data structures has a heavy runtime cost since you need to
allocate more memory to support instantiation of multiple objects. Using immutable
data then requires faster machines with more memory to run a program.&lt;/p&gt;

&lt;p&gt;This argument is a pure fallacy for two reasons.&lt;/p&gt;

&lt;p&gt;The first reason is technical. There are a lot of technical tricks to implement
immutable data without having a huge runtime cost. For example, in Scala,
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy()&lt;/code&gt; function generated for each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case class&lt;/code&gt; makes
a &lt;a href=&quot;https://docs.scala-lang.org/tour/case-classes.html&quot;&gt;shallow copy&lt;/a&gt; of a given object,
reducing drastically the runtime footprint of your program (compared to deep copy).&lt;/p&gt;

&lt;p&gt;The second reason is pure economics.
The &lt;a href=&quot;https://www.bls.gov/ooh/computer-and-information-technology/computer-and-information-research-scientists.htm&quot;&gt;average salary of a computer scientist is $122,840&lt;/a&gt;.
Tech companies such as Stripe or Google have the best engineers and still
spend 10% to 20% of their time dealing
with bad code (source: &lt;a href=&quot;https://stripe.com/reports/developer-coefficient-2018&quot;&gt;Stripe study&lt;/a&gt;).
To put it more clearly: the cost of bad code is more than $10,000 to $20,000 per developer
per year.&lt;/p&gt;

&lt;p&gt;The reality is: &lt;strong&gt;the cost of labor to write and maintain the software
is far higher than the cost of hardware&lt;/strong&gt;. Therefore, we should use all
potential methods (in terms of management, programming style or execution
platform) to reduce the labor costs. The use of immutability or functional
programming is only one candidate among others.&lt;/p&gt;

&lt;p&gt;Of course, engineers will &lt;em&gt;always&lt;/em&gt; believe they can outsmart the system
and produce a more efficient program by using some shady tricks (e.g. produce
better assembly cost than the C compiler). The reality
is that 99% of the time, they are dead wrong (e.g. compilers do a better job). And in the remaining 1%, the code should be carefully evaluated if this is worth the cost:
if the manual optimization is used, it will need to be maintained during the lifecyle
of the software (e.g. who wants to maintain assembly code if not an absolute necessity?).&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Dec 2020 23:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/software%20engineering/essay/immutability/scala/2020/12/11/on-immutability/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/software%20engineering/essay/immutability/scala/2020/12/11/on-immutability/</guid>
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        <category>scala</category>
        
        <category>immutability</category>
        
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        <category>immutability</category>
        
        <category>scala</category>
        
      </item>
    
      <item>
        <title>On team organization</title>
        <description>&lt;p&gt;&lt;em&gt;Note: this page is part of the &lt;a href=&quot;/software engineering/essay/2020/03/06/software-engineering-series&quot;&gt;‚ÄúEssays on Software Engineering‚Äù&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Over the years, I noticed many teams are organized around three main roles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Software Engineer (SWE)&lt;/strong&gt;: design, architect systems and write code.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Engineering Manager (EM)&lt;/strong&gt;: coordinate the life of the team, ensure work is being done, cares about promotion&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Product Manager (PM)&lt;/strong&gt;: interface between the customers and the engineering team, define the specification&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are some additional roles that comes into play, such as SWET (Software Engineer in Testing)
or SRE (System Reliability Engineering).&lt;/p&gt;

&lt;p&gt;Most of teams I have seen have at least one EM, few SWE and (sometimes)
one PM. But the other roles (SWET and SRE) are definitely not always
present and sometimes, part of a totally separate organization.&lt;/p&gt;

&lt;p&gt;In addition, there is always no specific role to review the documentation,
either internally or externally. And this part of the software development
becomes outdated very quickly.&lt;/p&gt;

&lt;p&gt;But lack of tests is what makes software unstable or introduce regressions.
Lack of documentation is what makes it hard to maintain. These aspects
are very often overlooked on the short term but have consequences on the
long term.&lt;/p&gt;

&lt;p&gt;There should be two ways to solve this problem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Reduce the number of SWE and add more SWET&lt;/strong&gt;. Let the software
engineer focus on writing code and let the SWET focus on writing code.
This solution has the benefit of introducing independent testing: the
test is not written by the author of the implementation. Similarly,
with such an approach, an editor should also maintain the documentation
of the system. Having an independent qualified editor would make sure the documentation
is correctly written and does not skip any detail.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Make testing and documentation an evaluation criteria for SWE&lt;/strong&gt;. Often,
testing and documentation are overlooked by SWE because they do not
consider them &lt;em&gt;valuable&lt;/em&gt;. EM should introduce incentives to write good
documentation and penalize engineers not writing enough tests or
documentation.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Dec 2020 23:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/software%20engineering/essay/2020/12/06/on-team-organization/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/software%20engineering/essay/2020/12/06/on-team-organization/</guid>
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        
        <category>software engineering</category>
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>Build software like you build a house</title>
        <description>&lt;p&gt;&lt;em&gt;Note: this page is part of the &lt;a href=&quot;/software engineering/essay/2020/03/06/software-engineering-series&quot;&gt;‚ÄúEssays on Software Engineering‚Äù&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/architectural-failure04.jpg&quot; alt=&quot;Requirements mismatches&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When you realize your interfaces do not match, too late in the development process.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;On 15 March 1986, the Hotel New York rapidly disintegrated in less than a minute at about 11:25 am&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The investigation led to the discovery that the original structural engineer had made a serious error in calculating the building‚Äôs structural load. The structural engineer had calculated the building‚Äôs live load (the weight of the building‚Äôs potential inhabitants, furniture, fixtures, and fittings) but the building‚Äôs dead load (the weight of the building itself) was completely omitted from the calculation. This meant that the building as constructed could not support its own weight. Collapsing was only a matter of time. After three different supporting columns failed in the days before the disaster, the other columns‚Äîwhich took on the added weight no longer supported by the failed columns‚Äîcould not support the building&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Collapse_of_Hotel_New_World#Casualties&quot;&gt;wikipedia source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Does that story sounds crazy to you? It should. Architectural failures
are rare, which is a good think. Yet, this is how we build software today
and failures are still very common in the software industry.&lt;/p&gt;

&lt;h1 id=&quot;the-building-metaphor&quot;&gt;The building metaphor&lt;/h1&gt;

&lt;p&gt;Building a new house follows a clear process that is more or less like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Establish the requirements (number of bathroom, bedrooms, placement, type of heat, etc.)&lt;/li&gt;
  &lt;li&gt;Inspect them, validate them with the different stakeholders (customers, suppliers, etc)&lt;/li&gt;
  &lt;li&gt;Work on an execution plan with milestones&lt;/li&gt;
  &lt;li&gt;Inspect the work by independent inspector.&lt;/li&gt;
  &lt;li&gt;Enjoy your new place.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example, if you build a house, you are going to start the foundations,
build the structure of the house, install the plumbing and electricity
and finally finish with the dry-wall/paint.
Everybody will understand you cannot start to install the bathtub if
the plumbing is not installed. You need to follow a specific order, otherwise,
you face major delays and cost impact (e.g. if you install the bathroom before
the plumbing is validated and checked, you might have to demolish the bathroom
to fix it later).&lt;/p&gt;

&lt;p&gt;Designing software follows the same rules and processes.&lt;/p&gt;

&lt;p&gt;For example, when you design a system with a database, you need
to understand the type of data, the frequency and type of access
before adding indexes or think of potential sharding schemes. These would be
your requirements. It will impact how you access or cache the data
but can also impact how you will deploy your system.&lt;/p&gt;

&lt;p&gt;However, very often, engineers overlook the most basic requirements and build systems
that are either not satisfying them (with system under-performing)
or go full berserk mode and over-satisfy them (with a higher implementation cost).
Both are not efficient. A great example here is the launch of the healthcare.gov:
the system was designed to handle 50,000 simultaneous connections when
250,000 people visited the website on
launch day (&lt;a href=&quot;https://en.wikipedia.org/wiki/HealthCare.gov#Issues_during_launch&quot;&gt;wikipedia&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The typical argument for a lack of attention on quality is that
software can be changed easily once delivered. This argument
is a fallacy, especially once the system is deployed in production. Changing
a system reliably while fully deployed in production is way
harder than changing it at design-phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/change-production.webp&quot; alt=&quot;Requirements mismatches&quot; /&gt;&lt;/p&gt;

&lt;p&gt;An engineer upgrading a system in production&lt;/p&gt;

&lt;h1 id=&quot;the-case-of-safety-critical-systems&quot;&gt;The case of safety-critical systems&lt;/h1&gt;

&lt;p&gt;Surprisingly, safety-critical systems (such as the one used in plane or rockets)
do not fail as much as regular ones.&lt;/p&gt;

&lt;p&gt;The main reasons is because as construction, these types of systems
are regulated and need to follow a rigorous production process that
catches such mistakes. Avionics and aerospace software follow
more or less the same constraints than software running nuclear power plants.
And surprisingly, these processes follow the same steps than
the one used to build a new house (start with the requirements,
validate them, have independent inspection, etc.). They also have clear
inspection and requirements to satisfy by law (note that interestingly, cars
are not as regulated).&lt;/p&gt;

&lt;p&gt;The takeaway: when you carefully follow a (good) process, you avoid
mistakes. As Bezos says: &lt;em&gt;Good intentions don‚Äôt work. Processes do&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;should-we-learn-better&quot;&gt;Should we learn better?&lt;/h1&gt;

&lt;p&gt;The main problem is the lack of knowledge. Projects do not fail intentionally,
they fail because engineers do not know better. There is a gap in knowledge, where
most engineers see software development only through the lens
of programming/coding and never heard what a software architecture is.&lt;/p&gt;

&lt;p&gt;We need to teach and explain what software architecture is
and how systems should be designed and built. These concepts have been missed,
especially in a world where we promise to become a software engineer
in just a few weeks of learning. In a world where most of the future
software engineers will not be able to get a degree before they enter
the workforce[1], it is becoming urgent to teach these values.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/architectural-failure02.jpg&quot; alt=&quot;Architecture School&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The solution for better software: be architects&lt;/p&gt;

&lt;p&gt;[1]&lt;a href=&quot;https://speakerdeck.com/heathermiller/the-times-they-are-a-changin&quot;&gt;The Times They Are a Changin‚Äô - Heather Miller talk&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Jun 2020 23:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/software%20engineering/essay/2020/06/21/build-software-like-you-build-a-house/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/software%20engineering/essay/2020/06/21/build-software-like-you-build-a-house/</guid>
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        
        <category>software engineering</category>
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>Do not take yourself too seriously</title>
        <description>&lt;p&gt;&lt;em&gt;Note: this page is part of the &lt;a href=&quot;/software engineering/essay/2020/03/06/software-engineering-series&quot;&gt;‚ÄúEssays on Software Engineering‚Äù&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I often encounter and work with people who believe they are inventing the wheel
and are so unique that you need to to listen to them and do exactly what they say
(in French, you would say &lt;em&gt;‚Äúils pensent avoir invent√© le fil √† couper le beurre‚Äù&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Such people take themselves too seriously. They believe that without them, the world
would not go round. They will try to block you for the sake of being right when
in fact, all what they are is annoying. Do not be such a person. They are full of
themselves. And very boring. Life is not made to be boring. You are better than
this.&lt;/p&gt;

&lt;p&gt;The academic world is full of such people, frustrated that they did
not find what their fellow neighbor invented and believe a solution cannot be good unless
they invent it. Many researchers are so frustrated
that they just reject others work, copy it, or tweak it slightly to finally claim
a new invention. There is even a name for it: &lt;a href=&quot;https://en.wikipedia.org/wiki/Not_invented_here&quot;&gt;Not Invented Here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, the very same behavior is present in the corporate world.
Remember that coworker who criticizes other projects because it was led
by their peers? Or the grumpy developer who re-implemented a piece of code
just because he does not like some obscure (and often, very subjective) aspect?
Would the reaction be the same if it was done by them?&lt;/p&gt;

&lt;p&gt;Remember how different teams duplicate work inside the same companies
instead of having shared code they can reuse? Or programmers not removing their
old deprecated code (aka &lt;em&gt;dead code&lt;/em&gt;) &lt;em&gt;‚Äújust in case‚Äù&lt;/em&gt; it might be useful?&lt;/p&gt;

&lt;p&gt;Duplicate efforts can be useful sometimes. For example, when creating
the iPhone, Jobs had two teams: one implementing the phone using software, the
other using hardware. In this exact case, the objective was to compare
two ways of doing one thing (we all know the result: the software variation won).
But the vast majority of times, duplicating work
is an ego issue, with people thinking they are better than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;insert-name-or-thing-here&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Do not be driven by your ego. This does not help you to move forward and
is mentally draining. This also does not help people around you.&lt;/p&gt;

&lt;p&gt;Instead, be driven by objective goals and metrics. If there is an objective
to improve quality of a particular piece of code, do not write a new project:
contribute to the existing one and improve its code coverage (remember
that &lt;a href=&quot;https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/&quot;&gt;re-writing projects from scratch rarely works&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;I believe there are two powerful principles to follow:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Be mindful of others.&lt;/li&gt;
  &lt;li&gt;Do not take yourself too seriously.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first principle is basic and yet, often overlooked. Try to put yourself in other people‚Äôs shoes
and understand how they feel. That will help you empathize with the difficulties
they might be having. This often explains why or how they react
to a particular person or event. This principle is also illustrated
by the habit &lt;em&gt;‚ÄúSeek to understand, then to be understood‚Äù&lt;/em&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/The_7_Habits_of_Highly_Effective_People&quot;&gt;The 7 habits of Highly Effective People&lt;/a&gt;, an amazing book I would recommend.&lt;/p&gt;

&lt;p&gt;The second principle is useful to put things in perspectives. You are a human
being who is failable by definition. You probably believe you are smart
and better than others because your mom, wife or dog told you.
In fact, as suggested by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect&quot;&gt;Dunning Kruger effect&lt;/a&gt;,
you are probably the worst person to know your own personal value.
This fact is illustrated every day in the stock market: many &lt;del&gt;gamblers&lt;/del&gt;
investors believe they can beat the market when in reality, all they
really achieve are losses. Similarly, many engineers believe they know how to
optimize code themselves manually when in reality, the compiler does it better
with optimization heuristics that have been implemented by researchers
and language specialists. You might like to think you are better than others
but you are probably not. Entertaining the idea of being that smart is
counter-productive and is not going to help you.&lt;/p&gt;

&lt;p&gt;You will make mistakes and this is going to be okay.
Your challenge is not to not make mistakes: you will do bad things sometimes, regardless how hard you try not to.
Your challenge is to put mechanisms and processes that will help you to avoid mistakes so that you catch them before you commit them.
In software, this is done by using defensive programming, increasing test coverage (unit/integration tests), and having good observability/monitoring.&lt;/p&gt;

&lt;p&gt;We do not succeed because we are better than others.
We succeed because we understand how to be successful with them.&lt;/p&gt;

&lt;p&gt;So get back to work, be nice and do not take yourself too seriously.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Thanks to Najwa for editing. üôè&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 23:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/misc/2020/04/03/do-not-take-yourself-too-seriously/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/misc/2020/04/03/do-not-take-yourself-too-seriously/</guid>
        
        <category>misc</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>Freedom</title>
        <description>&lt;p&gt;Within weeks, fundamental liberties have been sacrified in the name of safety.&lt;/p&gt;

&lt;p&gt;When we were previously infuriated by censorship and totalitarian governments,
we are now thankful to have &lt;del&gt;controlled&lt;/del&gt; curated information, either by
government or artificial intelligence. We are not even surprised when
our devices are used to track any progress of the disease when we were previously
worried about the use of device to track our moves. Nevermind if this is good or bad,
anything is good to sacrify in the name of safety. We
surrendered the right to be different or just disagree.
For ourselves or others.&lt;/p&gt;

&lt;p&gt;We accept to be forced to stay home. We accept to be controlled
and be told where to go, for how long. We accept to abdicate our
fundamental liberties.&lt;/p&gt;

&lt;p&gt;We fail to build a society where citizens are empowered to take decisions and
they rather accept to accept instructions at face value without any critical
thinking.&lt;/p&gt;

&lt;p&gt;Sad.&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/misc/2020/04/03/freedom/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/misc/2020/04/03/freedom/</guid>
        
        <category>misc</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>Outside</title>
        <description>&lt;p&gt;Today was a lucky day. I ran outside.&lt;/p&gt;

&lt;p&gt;The sun was shining, the streets were empty. Shops were closed.
The only few people I saw were other runners or homeless persons.&lt;/p&gt;

&lt;p&gt;Not sure how long it is going to last. We are ordered to stay
confined until experts evaluate we are safe to resume our lives.&lt;/p&gt;

&lt;p&gt;Nobody knows how deadly is this outbreak. Or how long this is going to last.&lt;/p&gt;

&lt;p&gt;Modern society prepared us for this. The latest information
is carefully crafted, curated and displayed in near real-time on all devices,
making each of us experts able to understand and evaluate
carefully the situation.&lt;/p&gt;

&lt;p&gt;Not sure for how long I will still have the permission to run outside.
Maybe soon I will have to stay inside, indefinitely.
That is for the good of the community, we cannot afford to take any risk.&lt;/p&gt;

&lt;p&gt;I trust our leaders to put an end to this situation.
No doubt that will be given the permission to go outside soon.
And that we will be able to enjoy time together again.&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/misc/2020/03/30/outside/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/misc/2020/03/30/outside/</guid>
        
        <category>misc</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>Manage projects like you run a race</title>
        <description>&lt;p&gt;&lt;em&gt;Note: this page is part of the &lt;a href=&quot;/software engineering/essay/2020/03/06/software-engineering-series&quot;&gt;‚ÄúEssays on Software Engineering‚Äù&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I used to run long distance trail races. My last race was in 2016, a 100 km
race in &lt;a href=&quot;https://www.dcnr.pa.gov/StateParks/FindAPark/WorldsEndStatePark/Pages/default.aspx&quot;&gt;Worlds End State Park&lt;/a&gt;, in the middle of Pennsylvania.
That particular day, I did not plan to finish the race: my body was already
exhausted from years of running without much rest, I only wanted to finish
the first 50k. Surprisingly, that day, my body felt good and at the 40 km mark,
a race volunteer convinced me to keep going as I was way ahead in terms of time.
Hours later, I finished the race about 15 minutes before the cut-off, limping,
around midnight, after running about several miles without a lamp.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/worldsends.jpg&quot; alt=&quot;Worlds Ends Race Picture&quot; /&gt;
The night before the race&lt;/p&gt;

&lt;p&gt;What went wrong that day? I did not plan to run 100k but 50k and
did not pack any battery or a lamp replacement. My mind was set on
running 50k from the start and not ready to go any longer. I did not plan
for the unexpected.&lt;/p&gt;

&lt;p&gt;It wasn‚Äôt like this before. When a race was less than 26 miles, I took it as a training run.
But when it was more than this, I meticulously planned it. I was
researching the elevation profile, checking support stations and
what food and liquids were provided. I prepare bags to drop at support stations located along the course and pack them with
more than twice of what I need: dry socks, food or a new t-shirt.
For each race, I clearly knew where and when I should be.&lt;/p&gt;

&lt;p&gt;When you think about it, a race is very simple: run X miles under Y hours.
There are constraints, such as the elevation profile, the weather or the type
of terrain. All of this can be planned and managed to reach the goal.
To succeed, all you need is to make sure you are trained, know what to
expect at regular interval of the race and have whatever you need through
the race.&lt;/p&gt;

&lt;p&gt;Over the years, I realized this process is no different than project management.
This is exactly the same.&lt;/p&gt;

&lt;p&gt;When you start a project, you also have a goal (deliver X within Y months),
some constraints and resources. As for a race, if the goal is not realistic,
you do not sign up and come back if or when you evaluate this being feasible.
Once you sign up, you establish a roadmap that tells you what and when
things should be completed. You have milestones that show you the incremental
progress you are going to do over time. It gives a clear overview of the
project work plan, not only to you but to the team that can also discuss
potential dependencies and organize for them to be delivered on time.&lt;/p&gt;

&lt;p&gt;Does it sound like basic project management to you? Yet, I still see many important projects
being started without even having milestones set. Engineers do not know
what they should be doing when they come to work. Even worse: sometimes, engineers
or managers do not even know what race they are running
(if they are running any). They are sometimes just lost in the company wilderness.&lt;/p&gt;

&lt;p&gt;When I start a project, I often try to plan it accordingly:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Have a clear overview of the feasibility&lt;/strong&gt;: if not feasible, either readjust the scope of do not take the project: better to deliver nothing than strong disappointment.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Research and plan&lt;/strong&gt;: like when preparing a race, look for the main obstacles
in your project and make a plan to overcome them. Define objectives and milestones
in a way they are measurable (e.g. I finished the code of module X by date Y).
Write them down and communicate them to all internal stakeholders (your team, your sister teams).
Communicate more pessimistic milestones for the customer so that you have some margin if things go wrong.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Regularly check your progress&lt;/strong&gt; to check you can finish the race before the cut-off.
Look at your milestones every week and re-evaluate your work plan if needed. If you are ahead of time, you might help some other
projects that need support or just finish your project earlier and polish it (better to under promise and over deliver).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Take large margins&lt;/strong&gt;: take at least 100% of margin, if you plan to complete a project in one month, ask for two months.
You might face unexpected issues, either human (one team member is ill or has some family issues) or technical and this margin is here to take the unexpected into account.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are simple rules. No matter how experienced you are, not following
them can transform a nice race halfway into a long nightmare. And regardless of
experience, many people do not apply them.&lt;/p&gt;

&lt;p&gt;Following these rules and processes helped me to manage multiple
projects simultaneously and deliver them before the estimated delivery time. I now schedule my life
according to them. It helped me to track what I should be doing and ensure
that I complete all the tasks I want to do within a day, a weekend or a month.&lt;/p&gt;

&lt;p&gt;Managing projects is very simple: manage them as you run a race.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Mar 2020 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/software%20engineering/essay/2020/03/06/manage-project-like-a-race/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/software%20engineering/essay/2020/03/06/manage-project-like-a-race/</guid>
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        
        <category>software engineering</category>
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>Essays on Software Engineering</title>
        <description>&lt;p&gt;After several years in the technology industry and living in various places,
I wanted to take the time to write some thoughts. Working on various
domains (such as aerospace, academia, data center management or ads),
living in different countries (or even states within the USA) and achieving
certains goals (such as losing half of my weight or running ultra distances)
helped me to see commonalities between domains and establish parallels
between worlds you would consider unrelated.&lt;/p&gt;

&lt;p&gt;Building software helped me to better understand real-life problems.
And leading non-tech projects also helped me building better software.&lt;/p&gt;

&lt;p&gt;One example would be fixing properties. When you fix a house,
you architect the new building, you schedule the work, establish milestones
and you clearly see dependencies. For example, you do not start painting before
the dry walls are properly installed and sealed. Yet, developers often
overlook such basic rules, even in regulated industries.&lt;/p&gt;

&lt;p&gt;For the next six months, I will write a new article each month that will
talk about one aspect similar to the one above. I have no idea or expectation about this
experiment, I just hope it will be as useful to you as it will be to me.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/software engineering/essay/2020/03/06/manage-project-like-a-race/&quot;&gt;Manage projects like you run a race&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/software engineering/essay/2020/06/21/build-software-like-you-build-a-house/&quot;&gt;Build software like you build a house&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/software engineering/essay/2020/12/06/on-team-organization/&quot;&gt;On team organization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Mar 2020 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/software%20engineering/essay/2020/03/06/software-engineering-series/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/software%20engineering/essay/2020/03/06/software-engineering-series/</guid>
        
        <category>software engineering</category>
        
        <category>essay</category>
        
        
        <category>software engineering</category>
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>Google is the new Microsoft</title>
        <description>&lt;p&gt;Google is the new Microsoft. What does that mean?&lt;/p&gt;

&lt;h2 id=&quot;some-history&quot;&gt;Some History&lt;/h2&gt;
&lt;p&gt;Let‚Äôs start by explaining what was Microsoft twenty years ago.&lt;/p&gt;

&lt;p&gt;Microsoft, is the company (or at least, his CEO) that once categorized
&lt;a href=&quot;https://www.theregister.co.uk/2001/06/02/ballmer_linux_is_a_cancer/&quot;&gt;Linux as cancer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is the company that did not respect technologies standards (especially
HTML/CSS) to put away competition, which resulted in a horrible developer
and user experience. Internet Explorer 6 was considered &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Explorer_6#Criticism&quot;&gt;one of the worst
product of all time&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is also the company that developed a collaborative scheduling Operating
System (all Windows before XP) when superior solutions already existed at the time.&lt;/p&gt;

&lt;p&gt;And worst, this is the company that integrated such pictures in a text editor.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/assets/clippy.gif&quot; alt=&quot;Working From Home&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This was the company with a crazy CEO (in the bad sense) &lt;a href=&quot;https://www.techradar.com/uk/news/phone-and-communications/mobile-phones/portable-devices/mp3-players/computing/apple/ballmer-apple-iphone-will-be-massive-flop-154018&quot;&gt;that predicted in 2007
the iPhone will be a flop&lt;/a&gt; and acquired Nokia (a company that was completely done and no future) after 2010.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Vhh_GeBPOhs&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Since then, the company is doing better, thanks to a new CEO that brought
the company back on track.&lt;/p&gt;

&lt;p&gt;But ten to twenty years ago, Microsoft was lost. They did not have good products,
no identity and no soul. And this is where Google is today.&lt;/p&gt;

&lt;h2 id=&quot;product-hell&quot;&gt;Product hell&lt;/h2&gt;

&lt;p&gt;The first Google products were great. I remember when GMail was offering
a GB to store my emails where Hotmail was offering 100 MB at most. The interface
was fast, convenient: everything you expected for such a product. They were
following key engineering principles: keep it simple and stupid.&lt;/p&gt;

&lt;p&gt;Over the years, products started to be bloated. And slow. GMail started to
look like Outlook or even Lotus Notes, especially on non-Chrome browsers.
Products started to be counter-intuitive, exactly how
Microsoft Word currently is. Google Cloud Console is the perfect example of a terrible
user experience where nothing is intuitive and you need to go to the
documentation &lt;strong&gt;each time&lt;/strong&gt; you use the product. There is a clear lack
of prioritization at the company where new features are stacked and developed
in spite of common design sense.&lt;/p&gt;

&lt;p&gt;There is also a clear lack of innovation. Over the last years, Google failed
to create new innovative products. Every attempt to start a social network
failed miserably and new products are being thrown into
the &lt;a href=&quot;https://gcemetery.co/&quot;&gt;Google cemetery&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;no-morale&quot;&gt;No morale&lt;/h2&gt;

&lt;p&gt;Inside the company, it seems there is no morale. The perfect example is
when the company did not immediately react to a sexual harassment case
and &lt;a href=&quot;https://www.cnet.com/news/google-reportedly-paid-andy-rubin-90m-despite-charge-of-sexual-misconduct/&quot;&gt;kept giving a $90M bonus package to the alleged culprit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The same low morale also applies to the products. Google that once praised
standardization is now behaving exactly like Microsoft, when they had
a monopoly in the browser market. It is now not a mystery that Google is
changing its web
applications to &lt;a href=&quot;https://gadgets.ndtv.com/apps/news/youtube-speed-faster-google-chrome-mozilla-firefox-microsoft-edge-1889651&quot;&gt;slow down competitors such as Firefox or Edge&lt;/a&gt;.
Exactly what Microsoft did with Internet Explorer 6 fifteen years ago.&lt;/p&gt;

&lt;p&gt;These repeated practices show that instead of innovating, Google is trying to
make the competitors look bad.&lt;/p&gt;

&lt;p&gt;Do you want to be their customers?&lt;/p&gt;

&lt;h2 id=&quot;do-not-be-evil&quot;&gt;Do not be evil&lt;/h2&gt;
&lt;p&gt;The story of Google is simple: the new cool kids were here to revolutionize
the internet. At the very beginning, Google was a game changer: a search
on the internet was taking less than a second. Their product were cool. And free.
They were the Microsoft anti-thesis.&lt;/p&gt;

&lt;p&gt;The spirit of the company was simple: be cool. Or rather: &lt;em&gt;Don‚Äôt be evil&lt;/em&gt;.
To developers, it meant a lot. It meant that somebody was doing the &lt;em&gt;right&lt;/em&gt; thing
and was not going to sell their soul.&lt;/p&gt;

&lt;p&gt;Unfortunately, this time is now gone, as the previous paragraphs shown.
It was officially &lt;a href=&quot;https://gizmodo.com/google-removes-nearly-all-mentions-of-dont-be-evil-from-1826153393&quot;&gt;reflected in the company internal documents in 2018&lt;/a&gt;.
And it is now &lt;em&gt;okay&lt;/em&gt; for Google to be evil.&lt;/p&gt;

&lt;p&gt;Make no mistake: Google is the new Microsoft.&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Dec 2019 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/microsoft/evil/google/2019/12/15/google-is-the-new-microsoft/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/microsoft/evil/google/2019/12/15/google-is-the-new-microsoft/</guid>
        
        <category>google</category>
        
        <category>new microsoft</category>
        
        
        <category>microsoft</category>
        
        <category>evil</category>
        
        <category>google</category>
        
      </item>
    
      <item>
        <title>Java or Scala, that is the question</title>
        <description>&lt;p&gt;Over the last two years, I had the opportunity to gain knowledge on Scala
and also re-learn Java (after about 3 years without using it). I built network
analysis tools in Scala and used it to entirely write the backend of
&lt;a href=&quot;https://www.code-inspector.com&quot;&gt;Code Inspector&lt;/a&gt; with it. In the meantime, when
starting to recently form a new engineering team, I had to use (and re-learn) Java again. I wanted
to reflect on this experience to share some thoughts as to where these languages
stand, the directions they are taking and answer the
question too-often asked: which one to use?&lt;/p&gt;

&lt;h1 id=&quot;java-has-evolved-a-lot-and-for-the-better&quot;&gt;Java has evolved a lot, and for the better&lt;/h1&gt;

&lt;p&gt;Java evolved a lot over its about 20 years of existence. From a simple object-oriented language, it
brought fundamental changes. One example is the change in the for-loop syntax
in Java 5 or the introduction of lambda in Java 8. As the language became very
popular, developers added a ton of libraries for it and the language became very
popular with infamous application (such as &lt;a href=&quot;https://hadoop.apache.org/&quot;&gt;Hadoop&lt;/a&gt;,
&lt;a href=&quot;https://spring.io/&quot;&gt;Spring&lt;/a&gt; or &lt;a href=&quot;https://www.playframework.com/&quot;&gt;Play&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Also, the community around the language built libraries to overcome some
of its limitations. One good example is &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;,
the library developed by Google that provides a lot of helper methods
and class to overcome some clear limitations of the language (e.g. the
lack of support of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt; - more on this later).&lt;/p&gt;

&lt;h1 id=&quot;functional-programming-has-proven-to-be-clean-and-effective&quot;&gt;Functional Programming has proven to be clean and effective&lt;/h1&gt;

&lt;p&gt;In the meantime, it is becoming clear that Object-Oriented programming (OO)
is not the silver bullet we thought it will be. Many people believed it was
a revolution in the programming world (e.g. Steve Jobs at
  was pitching the use of &lt;a href=&quot;https://computerhistory.org/blog/the-deep-history-of-your-apps-steve-jobs-nextstep-and-early-object-oriented-programming/&amp;gt;`_&quot;&gt;OO for NeXT&lt;/a&gt; long time ago, seeing it as revolutionary).
I belong to the group of engineers that were taught OO was the right way to build
programs (and even learned &lt;a href=&quot;https://en.wikipedia.org/wiki/Merise&quot;&gt;Merise&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Unified_Modeling_Language&quot;&gt;UML&lt;/a&gt;).
It is then no surprise that at first, I was very skeptical about the benefits of FP, especially after having used Java and
C++ for the last 5+ years. My interest in FP really started to increase after watching
this video of &lt;a href=&quot;https://en.wikipedia.org/wiki/John_Carmack&quot;&gt;John Carmack&lt;/a&gt; on the topic
where he explains the real issues our industry is facing and how FP is helping to write
simpler programs.&lt;/p&gt;

&lt;center&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/1PhArSujR_A&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/center&gt;

&lt;p&gt;After few months, it became obvious that Functional Programming (FP) helps to write programs
that are easier to maintain and reason about it. The use of immutability avoids
side-effects and basic errors such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt; that
have been plaguing programs for decades. As human, we fail to reason about
programs structure and do not build systems with the idea that people will
 maintain it for the years to come. And these problems increase as the size
 of the programs (and the number of engineers working on it) increases.
We can argue that these problems can be solved
using more processes and tools (static analyzer, automated checks during reviews, etc.),
but at the end of the day, what matters is to write something
simple from the start to avoid problems and additional work later in the development
process. The key idea is to keep thing simple from the start.
FP forces you to separate concerns (data vs. functions) and write
understandable code using &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; where outputs only depends on the inputs.&lt;/p&gt;

&lt;p&gt;From a mental model and design perspective, the clear separation between
data (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case class&lt;/code&gt; in Scala) and the functions that process it helps you to
reasons about your data flow. Finally, the use of pure functions facilitates
testing and is probably the biggest take-away from FP.&lt;/p&gt;

&lt;p&gt;There are many reasons that make FP superior to OO and so far, I believe that
the best summary has been written by Joe Amstrong, creator
of Erlang, who summarizes most of them in a &lt;a href=&quot;http://www.cs.otago.ac.nz/staffpriv/ok/Joe-Hates-OO.htm&quot;&gt;great essay&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;OO was probably a good intention but &lt;a href=&quot;https://nickfoy.com/blog/2018/4/7/good-intentions-dont-work&quot;&gt;good intentions don‚Äôt work&lt;/a&gt; (probably the best thing I learned from my time at Amazon).&lt;/p&gt;

&lt;h1 id=&quot;java-evolves-in-the-direction-of-scala&quot;&gt;Java evolves in the direction of Scala&lt;/h1&gt;

&lt;p&gt;It is now clear that Java is now taking the direction of Scala since several years
One of the obvious sign is the introduction of lambda in Java 8, a first-class
citizen concept of the Scala language.&lt;/p&gt;

&lt;p&gt;Another example is the push from the community to support Scala-like constructions
such as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt; in &lt;a href=&quot;https://github.com/google/guava&quot;&gt;guava&lt;/a&gt;
(or even the helper methods to improve the default implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toString&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equals&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; - there are plenty of examples).&lt;/p&gt;

&lt;p&gt;The last example in date is the project [Amber from Java|https://openjdk.java.net/projects/amber/)
that is copying core Scala features such as [pattern matching|https://openjdk.java.net/jeps/305], &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case class&lt;/code&gt;
(renamed &lt;a href=&quot;https://cr.openjdk.java.net/~briangoetz/amber/datum.html&quot;&gt;data classes&lt;/a&gt;) or &lt;a href=&quot;https://openjdk.java.net/jeps/286&quot;&gt;type inference&lt;/a&gt;.
Once project Amber is done, you could write code like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (obj instanceof String s || s.length() &amp;gt; 5) {s.contains(&quot;foo&quot;)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The exact same functionality exists in Scala since its inception and the same
code would look like&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj match {
  case s: String if s.length() &amp;gt; 5 =&amp;gt; s.contains(&quot;foo&quot;)
  case _ =&amp;gt; false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is that a bad thing that Java is copying Scala? In fact, this is really healthy.
And definitively shows the value of the concepts behind the language.
However, as these features are added on top of a already complex language, it brings
a new set of problems.&lt;/p&gt;

&lt;h1 id=&quot;you-cannot-get-rid-of-the-past&quot;&gt;You cannot get rid of the past&lt;/h1&gt;

&lt;p&gt;The biggest issue by introducing this new FP-compliant features on top of an old language is
the new level of complexity and the related ambiguity it might bring.
As the language needs to stay backward-compatible
with the existing feature, the new one are added without deprecating the old one,
which let programmers do whatever they wants since no rule will be enforced
by the compiler. This brings consistency issues in the codebase (use of multiple
coding patterns in the language), which confuses developers and make program
maintenance even more complex. One good example of such problem is large C++
codebase that tried to evolve to later versions (for example, when mixing
raw and smart pointers in C++).&lt;/p&gt;

&lt;p&gt;These additional features do not address the main shortcoming of the
language (OO, mutable variables, separation of concerns, etc.) and do not force the developer to use
FP. It offers the possibility to use it but does not mandate it, which means
that using FP must be enforced through a human process that is fallible by
definition. Not good.&lt;/p&gt;

&lt;h1 id=&quot;so-what-language-to-choose&quot;&gt;So what language to choose?&lt;/h1&gt;

&lt;p&gt;It is now clear that FP languages are superior in terms of maintenance, which
is the biggest cost in software today.&lt;/p&gt;

&lt;p&gt;One argument that is often made against Scala is the lack of candidates
that know Scala. That might be true if you are looking for a temporary position
but otherwise, if you hire a developer because of its familiarity
with a particular language, this is not good for the long term. It is better
to focus on the fundamentals (data structure, algorithms, etc.) than on
a particular technology. Learning Scala does not take much time. My experience after one year
  of teaching Scala showed me that engineers understands the fundamentals within a month).&lt;/p&gt;

&lt;p&gt;If you are starting a new project from scratch, Scala is a good choice and its
compatibility with Java lets you use any existing Java library
(and there are tons of it). That should
open the best of both worlds by having a great language a a ton of existing
and reliable libraries.&lt;/p&gt;

&lt;p&gt;But what if you already have an existing codebase, should you dump Java and start to rewrite everything in Scala? Probably not. Or at least,
not that fast. This would be a non-sense to dump a large codebase built, matured
and stabilized for years to only switch to a new language. And it would
also be an immediate, visible loss of productivity as all engineers are starting
to learn Scala. The best way forward is to start using new features of the language for the
existing code, and put processes (such as automatic checks) in place
to make sure the codebase stays consistent. If you start re-writing some
services or decompose them, it can be a good idea to start using Scala
(and its compatibility with Java helps in that direction) and let few engineers
explore and experiment the language (reducing the potential loss of productivity).
You can then judge for yourself how comfortable your engineers are with this
transition but also evaluates the potential benefits gradually.&lt;/p&gt;

&lt;h1 id=&quot;final-words&quot;&gt;Final Words&lt;/h1&gt;

&lt;p&gt;While this small article is in favor of Scala, the most important idea is
that Functional Programming principles help you writing re-usable and
maintainable code and that Object-Oriented principles were probably a mistake
the industry followed blindly. FP rules and principles can be implemented by
developers in almost any language (see Carmack talk mentioned above) And they
help you write better programs.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Oct 2019 13:13:20 +0000</pubDate>
        <link>http://julien.gunnm.org/development/agile/2019/10/23/java-vs-scala/</link>
        <guid isPermaLink="true">http://julien.gunnm.org/development/agile/2019/10/23/java-vs-scala/</guid>
        
        <category>java</category>
        
        <category>scala</category>
        
        
        <category>development</category>
        
        <category>agile</category>
        
      </item>
    
  </channel>
</rss>
